
В языке программирования Elixir определение функций и их организация осуществляются с помощью ключевых слов `def` и `defp`. Функции в Elixir структурируются внутри модулей, что способствует организации кода и инкапсуляции логики.

Модули и функции можно импортировать, больше об этом сказано в [[3.3 Импорт, алиасы и require]].

Функции могут иметь параметры по умолчанию, об этом сказано в [[3.4 Аргументы по умолчанию]].
## Определение функций с помощью `def`

Ключевое слово `def` используется для объявления публичных функций, которые доступны вне модуля, в котором они определены.

- **Публичная функция** — функция, которая может быть вызвана из других модулей или из внешнего кода.
- Синтаксис объявления публичной функции:

```scala
def имя_функции(аргументы) do
  тело_функции
end
```
- Имя функции должно быть атомом (например, `sum`, `calculate`), аргументы перечисляются в круглых скобках.
- Если функция не принимает аргументов, скобки можно опустить.
- Тело функции располагается между `do` и `end`.

### Пример публичной функции

```scala
def приветствие(имя) do
  "Привет, " <> имя
end
```
## Определение функций с помощью `defp`

Ключевое слово `defp` используется для объявления приватных функций, доступных только внутри того же модуля, где они определены.

- **Приватная функция** — функция, к которой нельзя обратиться извне модуля.
- Синтаксис приватной функции аналогичен публичной, но используется `defp`:

```lua
defp имя_функции(аргументы) do
  тело_функции
end
```
### Пример приватной функции

```css
defp удвоить(x) do
  x * 2
end
```
## Аргументы и арность функций

- **Арность** функции — это количество аргументов, которые функция принимает.
- В Elixir функции с одинаковым именем, но разным числом аргументов, считаются разными функциями (`имя/арность`).
- Пример: `sum/1` и `sum/2` — разные функции.

## Сопоставление с образцом (Pattern Matching) в определениях функций

- В Elixir разрешается определять несколько функций с одинаковым именем, но разными образцами аргументов.
- Elixir выбирает первую подходящую реализацию в зависимости от переданных аргументов.

```scala
def приветствие("Admin") do
  "Добро пожаловать, администратор"
end

def приветствие(имя) do
  "Привет, " <> имя
end
```
## Охрана (Guards) в определениях функций

- Ограничения на выполнение функции можно задавать с помощью охранных выражений (`when`).

```ruby
def делить(a, b) when b != 0 do
  a / b
end
```
- Если условия охраны не выполняются, Elixir ищет следующую подходящую реализацию функции.

## Краткая форма объявления функций

- Если тело функции состоит из одного выражения, можно использовать краткую форму объявления:

```scala
def квадрат(x), do: x * x
defp инкремент(x), do: x + 1
```
## Вложенность и области видимости функций

- Функции в Elixir нельзя объявлять внутри других функций.
- Публичные функции доступны из других модулей.
- Приватные функции доступны только внутри своего модуля.

## Рекурсия в функциях

- Язык Elixir не поддерживает традиционные циклы (`for`, `while`), вместо них используется рекурсия.
- Рекурсивные вызовы функций позволяют реализовывать итеративные процессы.

```python
def факториал(0), do: 1
def факториал(n) when n > 0, do: n * факториал(n - 1)
```
## Документирование функций

- Докстринги (docstrings) задаются с помощью специального атрибута `@doc` перед определением функции.
- Документирование позволяет генерировать документацию для модулей и функций.

```python
@doc "Возвращает квадрат числа"
def квадрат(x), do: x * x
```

## Практические применения

- Инкапсуляция логики в функциях способствует модульности, повторному использованию и тестируемости кода.
- Разделение функций на публичные и приватные обеспечивает контроль доступа и сокрытие реализации.
- Использование сопоставления с образцом и охран позволяет гибко обрабатывать различные случаи вызова функций.

## Ключевые принципы

- Функции в Elixir — чистые, не имеют побочных эффектов и всегда возвращают результат.
- Функции не изменяют внешние данные, а возвращают новые значения.
- Определение функций происходит только в рамках модулей.
- Использование `def` и `defp` позволяет создавать и организовывать публичный и приватный интерфейс.