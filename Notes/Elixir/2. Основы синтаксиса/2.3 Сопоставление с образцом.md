Сопоставление с образцом (pattern matching) в языке программирования Elixir представляет собой фундаментальный механизм, позволяющий связывать выражения с определёнными структурными формами. В основе сопоставления с образцом лежит оператор `=`, который отличается от классического оператора присваивания, так как осуществляет попытку сопоставить структуру левой части с правой, а не просто присваивает значение переменной.

## Определение и основные принципы

Оператор `=` в Elixir интерпретируется не как присваивание, а как попытка сопоставления (matching). Сопоставление считается успешным, если левая часть выражения может быть структурно приведена к виду правой части с учётом возможных переменных. Если сопоставление невозможно, генерируется ошибка `MatchError`.

## Общие правила сопоставления

- Если в левой части сопоставления находится переменная, она связывается со значением правой части.
- Если переменная уже связана со значением, сопоставление может быть успешным только при совпадении значений.
- Литералы (числа, строки, атомы) сопоставляются только с точным совпадением значений.
- Структурные типы данных (списки, кортежи, карты, структуры) сопоставляются по их форме и содержимому.

## Примеры базового сопоставления

```ruby
x = 1          # x связывается со значением 1
1 = x          # сопоставление успешно, так как x уже равен 1
2 = x          # ошибка MatchError, так как x равен 1
```
## Сопоставление с образцом и неизменяемость данных

В Elixir данные неизменяемы, поэтому сопоставление с образцом не изменяет значения уже существующих данных, а только создаёт новые связи между переменными и значениями.

## Сопоставление со структурами данных

- **Списки:**

   ```ruby
    [a, b, c] = [1, 2, 3]    # a = 1, b = 2, c = 3
    [h | t] = [1, 2, 3]      # h = 1, t = [2, 3]
    ```
**Кортежи:**

```ruby
{:ok, value} = {:ok, 42} # value = 42
{:error, _} = {:error, "fail"} # сопоставление успешно, переменная "_" игнорирует значение
```
**Карты:**

```ruby
%{a: x, b: y} = %{a: 1, b: 2, c: 3}  # x = 1, y = 2
```
## Одноразовая переменная (`_`)

Специальная переменная `_` используется для игнорирования значений. Она не связывает никакое значение и указывает на несущественную часть сопоставления.

## Сопоставление с уже связанными переменными (Pin operator `^`)

Если требуется сопоставить значение с уже существующей переменной, используется оператор `^` (pin operator):

```ruby
x = 2
^x = 2       # сопоставление успешно
^x = 3       # ошибка MatchError
```
## Сопоставление с вложенными структурами

Сопоставление возможно на произвольной глубине вложенности:

```ruby
[a, [b, c]] = [1, [2, 3]]   # a = 1, b = 2, c = 3
{{x, y}, z} = {{1, 2}, 3}   # x = 1, y = 2, z = 3
```
## Сопоставление в функциях и выражениях

- **Аргументы функций:**

   ```ruby
    defmodule Sample do
      def sum({a, b}), do: a + b
    end
    # вызов: Sample.sum({2, 3}) возвращает 5
    ```
**case-выражения:**

```ruby
case {1, 2, 3} do
  {1, x, 3} -> x
  _ -> 0
end
# возвращает 2
```
**with-выражения:**

```ruby
with {:ok, a} <- {:ok, 10},
     {:ok, b} <- {:ok, 20} do
  a + b
end
# возвращает 30
```

## Особенности сопоставления со списками

- С помощью нотации `[head | tail]` возможно разложение списка на первый элемент и "хвост".
- Сопоставление возможно только при совпадении длины структур, за исключением использования `|` для списков.
- Сравнение списков производится поэлементно.

## Сопоставление с образцом и рекурсия

Механизм сопоставления с образцом широко используется для рекурсивных функций, особенно при обработке списков и других коллекций. Благодаря сопоставлению функция может различать различные структуры данных на каждом этапе рекурсии.

## Практические применения сопоставления с образцом

- Реализация функций с различными вариантами поведения в зависимости от формы входных данных (мультиклаузы).
- Обработка ошибок и различение успешных/неуспешных результатов (например, `{:ok, value}` и `{:error, reason}`).
- Деструктуризация структур данных для получения отдельных элементов.
- Упрощение кода за счёт исключения необходимости явных проверок структуры данных.

## Заключительные замечания

- Сопоставление с образцом — ключевой инструмент для декларативного и выразительного программирования в Elixir.
- Он способствует написанию кода, устойчивого к ошибкам, и облегчает обработку сложных структур данных.