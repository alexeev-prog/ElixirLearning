Уже раннее можно было ознакомиться в [[1.2 Особенности]], [[4.3 Обновление структур]] и [[2.2 Структуры данных]].

Структуры (structs) в Elixir представляют собой специальную разновидность отображений (maps), обладающих фиксированным набором ключей и ассоциированных с определённым модулем. Они используются для организации и хранения связанных между собой данных с явной спецификацией структуры и типов полей. Структуры обеспечивают более строгую организацию данных по сравнению с обычными отображениями и поддерживают неизменяемость, являясь фундаментальным инструментом при построении сложных систем на Elixir.

## Определение структуры

Структуры определяются с помощью макроса `defstruct` внутри модуля. Этот макрос принимает список атрибутов, каждому из которых можно присвоить значение по умолчанию. После определения структуры автоматически создаётся специальный ключ `:__struct__`, указывающий на модуль-структуру.

```lua

defmodule User do
  defstruct name: nil, age: 0, email: ""
end
```
В приведённом примере определена структура `User` с полями `:name`, `:age` и `:email`, для которых заданы значения по умолчанию.

## Создание экземпляров структуры

Экземпляр структуры создаётся с использованием синтаксиса `%Module{}`:

```ini

user = %User{name: "Иван", age: 30}
```
Если какое-либо поле не указано при создании, оно принимает значение по умолчанию, определённое в `defstruct`.

## Особенности структур

- **Фиксированный набор ключей:** Структуры содержат только те ключи, которые определены в `defstruct`. Попытка добавить несуществующий ключ приведёт к ошибке компиляции.
- **Отображения с дополнительной семантикой:** Структуры реализованы поверх отображений, что обеспечивает совместимость с большинством функций, работающих с отображениями, но при этом структуры имеют дополнительный ключ `:__struct__`.
- **Неизменяемость:** Структуры, как и другие данные в Elixir, являются неизменяемыми. Любое изменение приводит к созданию новой структуры.
- **Сопоставление с образцом:** Структуры поддерживают сопоставление с образцом, что позволяет удобно извлекать данные и проверять тип структуры.
- **Ассоциация с модулем:** Каждая структура ассоциирована с модулем, что позволяет использовать дополнительные функции для работы с данной структурой.

## Доступ и обновление полей структуры

Доступ к полям структуры осуществляется с помощью точечной нотации:

```delphi

user.name
```
Обновление структуры выполняется при помощи синтаксиса `%Struct{struct | key: value}`:

```ini

updated_user = %User{user | age: 31}
```
При попытке обновить несуществующее поле возникнет ошибка компиляции.

## Преимущества использования структур

- **Явная спецификация полей:** Определение структуры делает явным набор допустимых полей, облегчая сопровождение и предотвращая ошибки, связанные с опечатками в ключах.
- **Интеграция с сопоставлением с образцом:** Структуры позволяют использовать сопоставление с образцом для проверки типа данных и извлечения значений.
- **Модули как пространство имён:** Каждая структура ассоциируется с модулем, что обеспечивает инкапсуляцию и организацию кода.
- **Совместимость с отображениями:** Структуры поддерживают большинство операций, применимых к отображениям, например, использование в `Map`-функциях.

## Ограничения и особенности структур

- **Нельзя создавать структуру с отсутствующими обязательными ключами:** При инициализации структуры должны быть заданы все ключи или для них должны быть определены значения по умолчанию.
- **Запрет на динамическое добавление новых ключей:** Невозможно добавить поля, не определённые в `defstruct`; это защищает структуру от случайных изменений.
- **Работа с протоколами:** Структуры могут реализовывать протоколы, что расширяет их функциональность и позволяет использовать полиморфизм на основе типов данных.
- **Поддержка инспекции и сериализации:** Структуры корректно отображаются в интерактивной оболочке и могут быть сериализованы/десериализованы с помощью стандартных средств языка.

## Сопоставление с образцом и проверка типа структуры

Сопоставление с образцом позволяет не только извлекать значения полей, но и проверять, принадлежит ли значение определённой структуре:

```ruby

case data do
  %User{name: name} -> {:user, name}
  _ -> :unknown
end
```
Проверку типа структуры можно также осуществить с помощью функции `is_struct/1` или `is_struct/2`:

```sql

is_struct(user)        # true, если user — любая структура
is_struct(user, User)  # true, если user — структура User
```
## Вложенные структуры

Поля структуры могут содержать другие структуры, что позволяет строить иерархические или составные типы данных. Необходимо явно указывать тип вложенной структуры и инициализировать её соответствующим образом.

```lua

defmodule Profile do
  defstruct bio: "", website: ""
end

defmodule User do
  defstruct name: nil, profile: %Profile{}
end
```

## Практические применения структур

- **Представление сущностей предметной области:** Использование структур для моделирования пользователей, заказов, товаров и других сущностей бизнес-логики.
- **Организация конфигураций:** Хранение и передача параметров конфигурации в виде структур для обеспечения явности и прозрачности.
- **Инкапсуляция состояния процессов:** Использование структур для представления состояния GenServer и других процессов, что облегчает модификацию и сопровождение кода.

## Примеры расширенного использования

- **Использование структур в протоколах:** Структуры могут реализовывать протоколы, такие как `String.Chars` для строкового представления или `Inspect` для пользовательской инспекции.
- **Обработка структур стандартными библиотеками:** Функции модуля `Map` работают со структурами, но могут требовать явного указания опции `drop: [:__struct__]` для удаления ключа `:__struct__` при необходимости преобразования в обычное отображение.
- **Преобразование между структурами и отображениями:** Для преобразования структуры к отображению используется функция `Map.from_struct/1`, а для преобразования отображения к структуре — синтаксис `struct(Module, map)`.

## Безопасность и валидация данных

Хотя структуры обеспечивают контроль над набором допустимых ключей, они не осуществляют проверку типов или валидацию значений полей. Для реализации валидации рекомендуется использовать вспомогательные функции, отдельные модули или сторонние библиотеки.

## Совместимость с неизменяемостью

Структуры полностью следуют принципу неизменяемости данных, принятому в функциональном программировании и реализованному в Elixir. Любое изменение структуры приводит к созданию нового экземпляра, что обеспечивает безопасность работы с данными в многопоточной среде и упрощает отладку.

## Резюме

- Структуры определяются через `defstruct` внутри модуля и представляют собой специализированные отображения с фиксированным набором ключей.
- Структуры предоставляют средства явной организации, хранения и сопоставления данных, ассоциируются с модулями и поддерживают неизменяемость.
- Они широко применяются для моделирования сущностей, организации конфигурации, инкапсуляции состояния и реализации протоколов.
- Структуры являются основой для построения устойчивых, сопровождаемых и надёжных систем на языке Elixir.