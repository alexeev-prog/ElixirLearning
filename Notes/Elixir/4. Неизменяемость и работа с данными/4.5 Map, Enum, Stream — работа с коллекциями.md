## Определение коллекций в Elixir

Коллекции в Elixir представляют собой структуры данных, которые могут содержать несколько элементов и обеспечивают различные способы хранения, доступа и обработки данных. К основным коллекциям относятся списки, кортежи, ключевые списки, ассоциативные массивы (Map), а также специализированные структуры, такие как Set и Struct.

## Map: ассоциативные массивы

**Map** (отображение, ассоциативный массив) — структура данных, позволяющая хранить пары "ключ—значение" с быстрым доступом по ключу. Ключи могут быть любого типа, а значения — произвольными данными. `Map` реализован как неизменяемая структура: любые изменения создают новый Map, оставляя исходный без изменений.

### Свойства Map

- Неупорядоченность. Порядок хранения элементов не гарантируется.
- Быстрый доступ к значениям по ключу.
- Поддержка различных типов ключей: числа, строки, атомы и другие.
- Встроенная поддержка в языке на уровне синтаксиса.

### Основные операции с Map

- Создание: `%{ключ => значение, ...}`
- Доступ по ключу: `map[ключ]` или `Map.get(map, ключ, значение_по_умолчанию)`
- Изменение: `Map.put(map, ключ, новое_значение)`
- Удаление: `Map.delete(map, ключ)`
- Объединение: `Map.merge(map1, map2)`
- Проверка наличия: `Map.has_key?(map, ключ)`

### Практические применения Map

- Хранение конфигураций и настроек.
- Представление структурированных данных (например, пользователей, заказов и др.).
- Промежуточное хранение результатов вычислений.
- Упрощение доступа к данным с неизвестной структурой.

## Enum: перечисление и обработка коллекций

**Enum** — модуль, предоставляющий набор функций для работы с коллекциями, реализующими протокол **Enumerable**. Основная особенность `Enum` — eager (жадная) стратегия вычислений: все элементы обрабатываются немедленно, а возвращаемый результат — новая коллекция или агрегированное значение.

### Ключевые понятия Enum

- **Жадные вычисления:** все элементы коллекции проходят обработку сразу.
- **Неизменяемость:** исходные коллекции не изменяются, создаётся новая коллекция при преобразованиях.
- **Универсальность:** поддерживает списки, Map, Range и любые структуры, реализующие `Enumerable`.

### Основные функции Enum

- **Преобразование:**
    - `Enum.map/2` — применяет функцию к каждому элементу коллекции, возвращает новую коллекцию.
    - `Enum.flat_map/2` — применяет функцию, возвращающую коллекцию, и объединяет результаты.
    - `Enum.filter/2` — фильтрует элементы по условию.
    - `Enum.reject/2` — исключает элементы, удовлетворяющие условию.
- **Агрегирование:**
    - `Enum.reduce/3` — сворачивает коллекцию к одному значению.
    - `Enum.sum/1`, `Enum.count/1`, `Enum.max/1`, `Enum.min/1` — вычисляют агрегированные значения.
- **Поиск:**
    - `Enum.find/2` — находит первый элемент, соответствующий условию.
    - `Enum.any?/2`, `Enum.all?/2` — проверяют условия на коллекции.
- **Сортировка и преобразование:**
    - `Enum.sort/1`, `Enum.sort_by/2` — сортировка элементов.
    - `Enum.uniq/1` — удаление дубликатов.

### Примеры использования Enum

```julia

Enum.map([1, 2, 3], fn x -> x * 2 end)    # [2, 4, 6]
Enum.filter([1, 2, 3, 4], fn x -> rem(x, 2) == 0 end)  # [2, 4]
Enum.reduce([1, 2, 3], 0, fn x, acc -> x + acc end)    # 6
```
### Практические применения Enum

- Массовая обработка данных в коллекциях.
- Фильтрация, сортировка и агрегация данных.
- Преобразование структур данных для последующего использования.
- Реализация цепочек преобразований.

## Stream: ленивые вычисления над коллекциями

**Stream** — модуль, предоставляющий ленивые (lazy) преобразования коллекций. В отличие от Enum, операции Stream не выполняются немедленно, а формируют цепочку вычислений, которые запускаются только при необходимости (при финальном вызове, например, `Enum.to_list/1`).

### Ключевые особенности Stream

- **Ленивые вычисления:** операции выполняются только при необходимости, что позволяет работать с потенциально бесконечными коллекциями.
- **Экономия памяти и ресурсов:** элементы обрабатываются по мере запроса, без создания промежуточных коллекций.
- **Композируемость:** операции Stream легко объединяются в цепочки для сложных преобразований.

### Основные функции Stream

- **Преобразование:**
    - `Stream.map/2` — создает ленивое отображение элементов.
    - `Stream.filter/2` — ленивое фильтрование элементов.
    - `Stream.flat_map/2` — ленивое отображение с объединением.
- **Генерация:**
    - `Stream.cycle/1` — бесконечный цикл элементов коллекции.
    - `Stream.iterate/2` — генерация бесконечной последовательности по функции.
    - `Stream.repeatedly/1` — генерация последовательности по функции-генератору.
- **Ограничение:**
    - `Stream.take/2` — взять первые N элементов.
    - `Stream.drop/2` — пропустить первые N элементов.
- **Ввод-вывод:**
    - `Stream.resource/3` — создание пользовательских ленивых потоков.
    - `Stream.unfold/2` — генерация потока на основе состояния.

### Примеры использования Stream

```vbnet

stream = Stream.map(1..100_000_000, fn x -> x * 2 end)
Enum.take(stream, 5)  # [2, 4, 6, 8, 10]
```

### Практические применения Stream

- Обработка больших или бесконечных последовательностей.
- Чтение и обработка файлов построчно.
- Потоковая обработка данных с минимальным использованием памяти.
- Интеграция с внешними источниками данных (например, сетевые потоки).

## Сравнение подходов: Map, Enum, Stream

- **Map** — ассоциативная коллекция для эффективного хранения и доступа по ключу.
- **Enum** — модуль для жадной обработки любых коллекций, реализующих протокол `Enumerable`.
- **Stream** — модуль для ленивой обработки коллекций, позволяющий выстраивать цепочки преобразований и работать с большими или бесконечными данными.

## Концепция неизменяемости в работе с коллекциями

Все коллекции в Elixir являются неизменяемыми: любые преобразования создают новые коллекции, не изменяя исходные. Это обеспечивает безопасность параллельных вычислений, предотвращает случайные модификации данных и способствует написанию чистого кода.

## Обобщённые принципы работы с коллекциями

- Для хранения структурированных данных используются Map и Struct.
- Массовые операции над коллекциями удобно реализуются через Enum.
- Для эффективной обработки больших или бесконечных данных применяются Stream.
- Преобразования обычно строятся в виде цепочек вызовов, обеспечивая декларативный стиль программирования.

## Практические рекомендации

- Использовать Enum для небольших или средних коллекций, когда требуется немедленное выполнение операций.
- Применять Stream для ленивой обработки и при работе с большими или потенциально неограниченными по размеру источниками данных.
- Для ассоциативных данных отдавать предпочтение Map, обеспечивающему быстрый доступ по ключу и семантическую выразительность.
- Стремиться к композиции операций для повышения читаемости, тестируемости и масштабируемости кода.